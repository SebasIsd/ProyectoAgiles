@page "/login"
@inject AuthService Auth
@inject NavigationManager Nav

@attribute [AllowAnonymous] 

<h2 class="mb-4">Iniciar Sesión</h2>

@if (!string.IsNullOrEmpty(error))
{
    <div class="alert alert-danger">@error</div>
}

<EditForm Model="@modelo" OnValidSubmit="@OnSubmit">
    <DataAnnotationsValidator />
    <ValidationSummary />

    <div class="mb-3">
        <label class="form-label">Usuario (correo)</label>
        <InputText class="form-control" @bind-Value="modelo.Correo" />
        <ValidationMessage For="@(()=>modelo.Correo)" />
    </div>

    <div class="mb-3">
        <label class="form-label">Contraseña</label>
        <InputText class="form-control" @bind-Value="modelo.Password" type="@inputType" />
        <ValidationMessage For="@(()=>modelo.Password)" />
        <div class="form-text"><a href="#" @onclick="Toggle">@(show ? "Ocultar" : "Mostrar")</a></div>
    </div>

    <button class="btn btn-primary" disabled="@loading">
        @(loading ? "Entrando..." : "Login")
    </button>
</EditForm>

@code {
    private LoginVm modelo = new();
    private bool loading, show;
    private string inputType => show ? "text" : "password";
    private string? error;

    public class LoginVm
    {
        [Required, EmailAddress] public string Correo { get; set; } = "";
        [Required, MinLength(4)] public string Password { get; set; } = "";
    }

    void Toggle() => show = !show;

    private async Task OnSubmit()
    {
        error = null; loading = true;

        // Opción A: si tu AuthService tiene este método que devuelve (bool ok, string? err)
        var result = await Auth.LoginAsync(modelo.Correo, modelo.Password);
        loading = false;

        if (result.ok) Nav.NavigateTo("/dashboard");
        else error = result.error ?? "Error de login.";
    }
}

